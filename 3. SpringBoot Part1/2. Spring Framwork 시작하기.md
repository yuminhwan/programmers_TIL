## Spring Framework

### Spring Projects

Spring은 **여러 프로젝트**로 구성되어 있는 자바 기반의 프로그래밍에 있어서 방대한 기능을 제공하는 Framework라고 볼 수 있다.

물론 다른 프로젝트들의 근간은 Spring Framework 프로젝트이고 모두 Spring Framework와 의존관계를 가진다.

실제로 스프링 프레임워크를 이요해서 웹 애플리케이션을 개발할 때는 스프링 프레임워크만 단독으로 사용하기 보다 여러 스프링 관련 프로젝트를 함께 사용한다. (Spring Boot, Spring Data, ..)



### Spring Framework 

- `Core technologies`
- `Testing`
- `Data Access`
- `Spring MVC and Spring WEbFlux`
- `Integration`
- `Languages`



### Spring Boot

스프링부트는 여러 프로젝트 중 하나의 프로젝트로 다음과 같은 기능을 제공한다. 

- SpringApplication을 통한 손쉬운 실행 
- Auto Configuration 
- 쉬운 외부 환경 설정 - Propertiesm, YAML, Command line 설정 등 
- 프로파일을 통한 실행환경 관리 
- Packaging Executable Jar
- Developer Tools 



### Spring Framework 핵심 개념

- Spring IOC 컨테이너와 Beans
- 리소스 핸들링 (Resource와 ResourceLoader)
- 벨리데이션과 데이터 바인딩 그리고 타입 변환
- 스프링 expression 언어 
- AOP 
- Null-safety
- 데이터 버퍼와 코덱 
- 로깅



## 주문관리 애플리케이션

### Entity

엔터티는 다른 엔터티와 구별할 수 있는 식별자(개별성)를 가지고 있고 시간에 흐름에 따라 지속적으로 변경이 되는 객체이다

![Untitled Diagram.drawio](https://tva1.sinaimg.cn/large/e6c9d24egy1h0xt3mm5s6j20eh051aa1.jpg)



### Value Object 

값 객체는 각 속성이 개별적으로 변화하지 않고 값 그 자체로 고유한 **불변 객체**이다.

불변 객체는 내부 상태가 시간이 흘러도 고정이고 변경될 수 없기에 여러 쓰레드에서 안전하게 공유될 수 있다.

```java
public enum OrderStatus {
    ACCEPTED,
    PAYMENT_REQUIRED,
    PAYMENT_CONFIRMED,
    READY_FOR_DELIVERY,
    SHIPPED,
    SETTLED,
    CANCELLED
}

public record OrderItem(UUID productId,
                        long productPrice,
                        long quantity) {
}

public class Order {
    private final UUID orderId;
    private final UUID customerId;
    private final List<OrderItem> orderItems;
    private long discountAmount;
    private OrderStatus orderStatus = OrderStatus.ACCEPTED;

    public Order(UUID orderId, UUID customerId, List<OrderItem> orderItems, long discountAmount) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.orderItems = orderItems;
        this.discountAmount = discountAmount;
    }

    public long totalAmount() {
        var beforeDiscount = orderItems.stream()
            .map(v -> v.productPrice() * v.quantity())
            .reduce(0L, Long::sum);

        return beforeDiscount - discountAmount;
    }

    public void setDiscountAmount(long discountAmount) {
        this.discountAmount = discountAmount;
    }

    public void setOrderStatus(OrderStatus orderStatus) {
        this.orderStatus = orderStatus;
    }
}
```



#### Record

자바 14부터 지원하며 class, enum, interface와 같은 타입 선언이다.

record는 **불변 데이터 집합**이며 명목상 튜플이다.

```java
public record Point(int x, int y) {
}
```

record를 만들면 다음과 같은 내용이 처리된다. 

- private final 필드로 선언된다.
- public으로 읽기 접근 메서드가 같은 이름과 타입으로 만들어 진다. 
	- 즉, public int x(), public int y()
- 초기화하는 public 생성자도 만들어 진다.
- equals, hashCode, toString 의 구현도 만들어진다.



```java
public record Point(int x, int y) {

    public static void main(String[] args) {
        Point point = new Point(1, 2);
        System.out.println("x = " + point.x() + ", y = " + point.y());  
        // x = 1, y = 2
        System.out.println(point.equals(new Point(1, 2)));    // true 
        System.out.println(point.hashCode());    // 33
        System.out.println(point);              // Point[x=1, y=2]
    }
}
```

### 의존성 관리 

#### 의존성 이란?

어떤 객체가 협력하기 위해 다른 객체를 필요로 할 때 두 객체 사이의 의존성이 존재하게 된다. 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다. 

- 컴파일타임 의존성 : 코드를 작성하는 시점에서 발생하는 의존성 / 클래스 사이의 의존성 
- 런타임 의존성 : 애플리케이션이 실행되는 시점의 의존성 / 객체 사이의 의존성 

![image-20220404185040867](https://tva1.sinaimg.cn/large/e6c9d24egy1h0xu4n5pw8j20xc0jn759.jpg)

```java
public class FixedAmountVoucher {
    private final long amount;

    public FixedAmountVoucher(long amount) {
        this.amount = amount;
    }

    public long discount(long beforeDiscount) {
        return beforeDiscount - amount;
    }
}

public class Order {
    private final UUID orderId;
    private final UUID customerId;
    private final List<OrderItem> orderItems;
    private final FixedAmountVoucher fixedAmountVoucher;
    private OrderStatus orderStatus = OrderStatus.ACCEPTED;

    public Order(UUID orderId, UUID customerId, List<OrderItem> orderItems,
        long discountAmount) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.orderItems = orderItems;
        this.fixedAmountVoucher = new FixedAmountVoucher(discountAmount);
    }

    public long totalAmount() {
        var beforeDiscount = orderItems.stream()
            .map(v -> v.getProductPrice() * v.getQuantity())
            .reduce(0L, Long::sum);

        return fixedAmountVoucher.discount(beforeDiscount);
    }

    public void setOrderStatus(OrderStatus orderStatus) {
        this.orderStatus = orderStatus;
    }
}

public class OrderTester {
    public static void main(String[] args) {
        var customerId = UUID.randomUUID();
        var orderItems = new ArrayList<OrderItem>() {{
            add(new OrderItem(UUID.randomUUID(), 100L, 1));
        }};
        var order = new Order(UUID.randomUUID(), customerId, orderItems, 10L);
        Assert.isTrue(order.totalAmount() == 90L,
            MessageFormat.format("totalAmount{0} is not 90L", order.totalAmount()));
    }
}
```



#### double brace initialization

```java
public class Main {
    public static void main(String[] args) {
        List<Integer> numbers1 = new ArrayList<>();
        numbers1.add(1);
        numbers1.add(2);

        List<Integer> numbers2 = new ArrayList<>() {{
            add(1);
            add(2);
        }};

        System.out.println(numbers1); // [1, 2]
        System.out.println(numbers2); // [1, 2]

        System.out.println(numbers1.getClass());  // class java.util.ArrayList
        System.out.println(numbers2.getClass());  // class org.prgrms.kdt.Main$1
    }
}
```

인스턴스 생성과 함께 초기화가 가능하지만 지양해야 할 안티 패턴이다. 

위의 결과를 보면 class가 사실 익명 클래스로 넘어온다는 것을 확인할 수 있다. 

이러한 까닭에 double brace initialization을 하면, JVM이 새로운 클래스 파일을 읽어야 하는 부담도 생기고, 클래스 파일이 늘어남에 따라 저장 공간에 부담이 생기게 된다. 또한, 바깥 인스턴스에 대한 숨겨진 참조를 가지기 때문에 메모리 누수를 일으킬 수 있다.



### 결합도 

결합도란 `하나의 객체가 변경이 일어날 때에 관계를 맺고 있는 다른 객체에게 변화를 요구하는 정도`이다.

어떤 두 요소 사이에 존재하는 의존성이 바람직할 때 두 요소가 **느슨한 결합도 또는 약한 결합도**를 가진다고 말한다. 반대로 두 요소의 의존성이 바람직하지 못할 때 **단단한 결합도 또는 강한 결합도**를 가진다고 말한다.

위에서 봤던 코드의 결합도를 느슨하게 만들어 보자.

```java
public interface Voucher {

    UUID getVoucherId();

    long discount(long beforeDiscount);
}

public class FixedAmountVoucher implements Voucher {
    private final UUID voucherId;
    private final long amount;

    public FixedAmountVoucher(UUID voucherId, long amount) {
        this.voucherId = voucherId;
        this.amount = amount;
    }

    @Override
    public UUID getVoucherId() {
        return voucherId;
    }

    @Override
    public long discount(long beforeDiscount) {
        return beforeDiscount - amount;
    }
}

public class PercentDiscountVoucher implements Voucher {
    private final UUID voucherId;
    private final long percent;

    public PercentDiscountVoucher(UUID voucherId, long percent) {
        this.voucherId = voucherId;
        this.percent = percent;
    }

    @Override
    public UUID getVoucherId() {
        return voucherId;
    }

    @Override
    public long discount(long beforeDiscount) {
        return beforeDiscount * (percent / 100);
    }
}

public class Order {
    private final UUID orderId;
    private final UUID customerId;
    private final List<OrderItem> orderItems;
    private final Voucher voucher;
    private OrderStatus orderStatus = OrderStatus.ACCEPTED;

    public Order(UUID orderId, UUID customerId, List<OrderItem> orderItems, Voucher voucher) {
        this.orderId = orderId;
        this.customerId = customerId;
        this.orderItems = orderItems;
        this.voucher = voucher;
    }

    public long totalAmount() {
        var beforeDiscount = orderItems.stream()
            .map(v -> v.getProductPrice() * v.getQuantity())
            .reduce(0L, Long::sum);

        return voucher.discount(beforeDiscount);
    }

    public void setOrderStatus(OrderStatus orderStatus) {
        this.orderStatus = orderStatus;
    }
}
```

이런 식으로 구현하게 되면Order은 Voucher와 컴파일타임 의존성이고 각 구상체인 PercentDiscountVoucher, FixedAmountVoucher와는 런타임 의존성을 가지게 되어 느슨한 결합도를 가지게 되었다.

